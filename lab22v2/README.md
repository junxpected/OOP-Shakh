# Лабораторна робота №22

**Тема:** LSP – виявлення порушень і альтернативи

## Мета роботи
Поглибити розуміння принципу підстановки Лісков (LSP), навчитися виявляти його порушення в ієрархіях класів та застосовувати альтернативні підходи для створення LSP‑сумісних рішень.

---

## Опис початкової ієрархії
У початковій реалізації був створений базовий клас `Bird`, який містить метод `Fly()`. Контракт цього класу передбачає, що будь‑який об’єкт типу `Bird` може літати.

### Початковий код (порушення LSP)
```csharp
class Bird
{
    public virtual void Fly()
    {
        Console.WriteLine("Bird is flying");
    }
}

class Penguin : Bird
{
    public override void Fly()
    {
        throw new NotImplementedException("Penguins cannot fly");
    }
}
```

Також був реалізований клієнтський метод, який працює з базовим типом `Bird`:

```csharp
public static void MakeBirdFly(Bird bird)
{
    bird.Fly();
}
```

---

## Аналіз порушення принципу LSP
Принцип підстановки Лісков стверджує, що об’єкти похідного класу повинні безпечно підставлятися замість об’єктів базового класу без порушення коректності програми.

У даному випадку:
- базовий клас `Bird` гарантує наявність працюючого методу `Fly()`;
- клас `Penguin` порушує цей контракт, викидаючи виняток;
- клієнтський код ламається при підстановці `Penguin`.

Отже, `Penguin` не є коректною заміною для `Bird` — це пряме порушення LSP.

---

## Альтернативне рішення (зміна ієрархії)
Щоб усунути проблему, змінюємо ієрархію: не вважати, що всі птахи вміють літати. Вводимо інтерфейси:

```csharp
interface IBird
{
    void Move();
}

interface IFlyingBird
{
    void Fly();
}
```

### Реалізація класів
```csharp
class Sparrow : IBird, IFlyingBird
{
    public void Move()
    {
        Console.WriteLine("Sparrow is walking");
    }

    public void Fly()
    {
        Console.WriteLine("Sparrow is flying");
    }
}

class PenguinFixed : IBird
{
    public void Move()
    {
        Console.WriteLine("Penguin is swimming");
    }
}
```

---

## Чому нове рішення дотримується LSP
- класи не реалізують методи, які не можуть бути коректно виконані;  
- відсутні методи, що викидають винятки через неможливість виконання;  
- клієнтський код працює з правильними абстракціями (`IBird`, `IFlyingBird`);  
- кожен клас дотримується контракту свого інтерфейсу.

---

## Демонстрація коректної роботи

![alt text](image-1.png)

Код працює коректно та без помилок.

---

## Висновки
Виявлено порушення LSP через неправильне використання наслідування. Після рефакторингу (зміна ієрархії та використання інтерфейсів) проблема усунена. Дотримання LSP забезпечує стабільніший, зрозуміліший та розширюваний код.
