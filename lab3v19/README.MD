Звіт до лабораторної роботи №3
Дата: 27 вересня 2025 року
Шах Святослав ІПЗ 3/1

Опис роботи:
Добре, я підготую звіт у форматі Markdown для лабораторної роботи №3 за варіантом 19 "Часові інтервали" без включення фактичного коду, дотримуючись усіх вимог до структури звіту.

Звіт до Лабораторної роботи №3: Наслідування: основи
Тема: Наслідування: основи
Мета: закріпити знання про базові класи, похідні класи, модифікатори доступу, використання base, поліморфізм у простій формі.
1. Опис виконання завдання (Варіант 19: Часові інтервали)
Для реалізації варіанту "Часові інтервали" було спроєктовано ієрархію класів, що моделює різні часові проміжки у розкладі дня.

1.1. Структура класів
Базовий клас: TimeSpanBase
Призначення: Представляє загальний часовий інтервал.
Захищені поля (protected): _hours, _minutes, _seconds для зберігання тривалості.
Конструктор: Ініціалізує захищені поля.
Віртуальні методи (virtual):
GetDuration(): Обчислює загальну тривалість інтервалу у секундах.
GetInfo(): Повертає загальну інформацію про тривалість.
Похідний клас 1: LessonTime (Час заняття)
Успадкування: Наслідує TimeSpanBase.
Власне поле: Приватне поле (private) для назви предмету (_subjectName).
Конструктор: Приймає параметри часу та назву предмету. Обов'язково викликає конструктор базового класу за допомогою base(h, m, s).

Перевизначення методів (override):

override GetDuration(): Повертає тривалість заняття в секундах.

override GetInfo(): Повертає інформацію, включаючи назву предмету.

Похідний клас 2: BreakTime (Час перерви)

Успадкування: Наслідує TimeSpanBase.

Власне поле: Приватне поле (private) для типу перерви (_breakType).

Конструктор: Приймає параметри часу та тип перерви. Обов'язково викликає конструктор базового класу за допомогою base(h, m, s).

Перевизначення методів (override):

override GetInfo(): Повертає інформацію, включаючи тип перерви.

1.2. Демонстрація поліморфізму
У головному методі (Program.cs) була створена колекція типу базового класу: List<TimeSpanBase> schedule.
Ця колекція містить об'єкти як LessonTime, так і BreakTime. Ітерація по колекції та виклик віртуальних/перевизначених методів (наприклад, timeSpan.GetInfo() або timeSpan.GetDuration()) демонструє поліморфізм часу виконання. Система автоматично визначає, який саме метод (з TimeSpanBase, LessonTime чи BreakTime) потрібно викликати, забезпечуючи коректне виведення інформації для кожного типу інтервалу.

1.3. Обчислення
Були виконані наступні розрахунки:

Обчислення загальної тривалості занять: Шляхом підсумовування результатів GetDuration() виключно для об'єктів типу LessonTime.

Обчислення загальної тривалості перерв: Шляхом підсумовування результатів GetDuration() виключно для об'єктів типу BreakTime.

Формування розкладу дня: Послідовне виведення інформації про кожен часовий інтервал за допомогою поліморфного виклику GetInfo().

2. Приклади запуску (Скріншоти виводу програми)
[Вставте тут скріншот(и) виводу вашої програми.]
Очікуваний вивід:

Перелік усіх часових інтервалів (Розклад дня) з назвами предметів або типами перерв.

Виведений загальний час, витрачений на заняття, та загальний час, витрачений на перерви.

Контрольні запитання
Що таке наслідування та для чого воно використовується?

Наслідування (Inheritance) — це механізм ООП, що дозволяє створювати похідний клас (subclass) на основі існуючого базового класу (superclass). Похідний клас успадковує (отримує) поля та методи базового класу.

Використання: Для повторного використання коду (уникнення дублювання логіки), для встановлення ієрархічних зв'язків "є різновидом" (Is-A relationship) між класами та для забезпечення поліморфізму.

Чим відрізняється virtual від abstract методу?

virtual метод: Це звичайний метод у базовому класі, який має тіло (реалізацію). Його можна (але не обов'язково) перевизначити (override) у похідних класах, щоб змінити його поведінку.

abstract метод: Це метод, який не має тіла (реалізації) і оголошений у абстрактному класі. Похідні класи зобов'язані надати його реалізацію (перевизначити його), якщо вони самі не є абстрактними.

Як працює ключове слово base?

Ключове слово base використовується всередині похідного класу для доступу до членів базового класу.

Найчастіше воно використовується:

Для виклику конструктора базового класу з конструктора похідного класу (: base(...)). Це єдиний спосіб ініціалізувати приватні або захищені поля базового класу.

Для виклику перевизначеного методу базового класу (base.MethodName()) зсередини методу похідного класу, щоб розширити, а не повністю замінити, його функціональність.

Що таке поліморфізм часу виконання?

Поліморфізм (Polymorphism) (з грец. "багато форм") — це можливість об'єктів різних класів відповідати на один і той же виклик по-різному.
Поліморфізм часу виконання (Runtime Polymorphism), або динамічний поліморфізм, реалізується через віртуальні методи (virtual/override). Це означає, що програма лише під час виконання (Runtime) визначає, який саме метод буде викликаний для об'єкта, посиланням на який є базовий тип. Це дозволяє працювати з колекцією об'єктів базового типу, але викликати методи, специфічні для їхнього фактичного похідного типу.

У чому різниця між композицією та наслідуванням?

Наслідування (Inheritance - "Is-A"): Встановлює зв'язок "є різновидом" (наприклад, Car є різновидом Transport). Це механізм білої скриньки, де похідний клас має доступ до захищених членів базового. Використовується для повторного використання реалізації та для поліморфізму.

Композиція (Composition - "Has-A"): Встановлює зв'язок "має" (наприклад, Car має Engine). Це механізм чорної скриньки, де один клас містить посилання на об'єкт іншого класу і делегує йому роботу. Використовується для гнучкості та агрегації функціональності, коли клас потребує можливостей іншого класу, а не є його різновидом. Композиція зазвичай є більш гнучким підходом.


Примітки:
Код завантажено до репозиторію Git з додаванням звіту та оновленим .gitignore для ігнорування тимчасових файлів (bin/, obj/).