# Звіт з аналізу принципів SRP та OCP в open-source проєкті
**Виконав:** Шах Свтослав
**Група:** ІПЗ 3/1
## 1. Обраний open-source проєкт-
 **Назва проєкту:** CSharp-Project- 
 **Автор:** Yusuf Shakeel- 
 **Посилання на GitHub:** https://github.com/yusufshakeel/CSharp-Project

 Даний проєкт є відкритим репозиторієм на мові програмування C#. Він містить приклади програм та класів, які можна використати для аналізу принципів SOLID, зокрема SRP та OCP.
 ## 2. Аналіз SRP (Single Responsibility Principle)
 Принцип SRP означає, що кожен клас повинен виконувати тільки одну логічну задачу.
 ### 2.1. Приклади порушення SRP

 #### Клас: `Form1` (проєкт ImageViewer)
 У даному проєкті клас `Form1` порушує принцип SRP, оскільки виконує декілька різних функцій одночасно.
 **Множинні відповідальності класу `Form1`:
 **- робота з графічним інтерфейсом (Windows Form)
 - відкриття файлів зображень
 - збереження зображень у файл
 - керування життєвим циклом програми (вихід з програми)
 
 Фрагмент коду:
 
 ```csharp
private void openToolStripMenuItem_Click(object sender, EventArgs e)
{
    OpenFileDialog ofd = new OpenFileDialog();
    ofd.Filter = "jpg (*.jpg)|*.jpg|bmp (*.bmp)|*.bmp|png (*png)|*.png";


    if (ofd.ShowDialog() == DialogResult.OK && ofd.FileName.Length > 0)
    {

        pictureBox1.SizeMode = PictureBoxSizeMode.Zoom;
        pictureBox1.Image = Image.FromFile(ofd.FileName);
    }
}
```
 
 Також у цьому ж класі знаходиться логіка збереження файлів та виходу з програми, що означає наявність кількох причин для зміни класу. Це є порушенням принципу SRP.
 **Можливі проблеми:**
 - складність підтримки коду
 - важко повторно використовувати логіку роботи з файлами
 
 ## 3. Аналіз OCP (Open/Closed Principle)(Open/Closed Principle)
 Принцип OCP означає, що програмні модулі повинні бути відкритими для розширення, але закритими для зміни.
 ### 3.1. Приклад порушення OCP
  У класі `Form1` логіка оновлення прогрес-бара жорстко закодована. Наприклад, швидкість заповнення та спосіб малювання не можна змінити без редагування методу `t_Tick`.
  
Фрагмент коду:
  
  ```csharp
bComplete++;
if (pbComplete > 100)
{

    g.Dispose();
    t.Stop();
}
  ```
  
  Якщо потрібно змінити спосіб обчислення прогресу або додати інший тип прогрес-бара, доведеться змінювати існуючий код, що порушує принцип OCP.
  ### 3.2. Як можна було б дотриматися OCP
  Для кращого дотримання OCP логіку прогресу та малювання можна винести в окремі класи або інтерфейси. Тоді нові типи прогрес-барів можна було б додавати без зміни класу `Form1`.
  ### 3.2. Приклад порушення OCP
  ```csharp
public int Calculate(string type, int a, int b)
{
    if (type == "add") return a + b;
    if (type == "sub") return a - b;
    if (type == "mul") return a * b;
return 0;
}
  ```
  У цьому випадку для додавання нової операції потрібно змінювати метод, що порушує принцип OCP.
  ## 4. Висновки
  Під час аналізу було помічено, що в проєкті є як приклади дотримання принципів SRP та OCP, так і їх порушення. Принцип SRP зазвичай дотримується у простих класах, але порушується в основному методі програми. Принцип OCP реалізується при використанні інтерфейсів, але порушується при використанні умовних операторів. В цілому проєкт можна вважати задовільним з точки зору застосування SOLID принципів.